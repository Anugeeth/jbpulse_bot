/**
 * Beckn ODR API Specification
 * Adaptation of Beckn protocol for the ODR sector.
 *
 * The version of the OpenAPI document: 1.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Code from './Code';
import Context from './Context';
import Location from './Location';
import Model0 from './Model0';

/**
 * The SupportPostRequestContext model module.
 * @module model/SupportPostRequestContext
 * @version 1.1.0
 */
class SupportPostRequestContext {
    /**
     * Constructs a new <code>SupportPostRequestContext</code>.
     * @alias module:model/SupportPostRequestContext
     * @implements module:model/Context
     * @param action {module:model/SupportPostRequestContext.ActionEnum} 
     */
    constructor(action) { 
        Context.initialize(this);
        SupportPostRequestContext.initialize(this, action);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, action) { 
        obj['action'] = action;
    }

    /**
     * Constructs a <code>SupportPostRequestContext</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/SupportPostRequestContext} obj Optional instance to populate.
     * @return {module:model/SupportPostRequestContext} The populated <code>SupportPostRequestContext</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new SupportPostRequestContext();
            Context.constructFromObject(data, obj);

            if (data.hasOwnProperty('domain')) {
                obj['domain'] = ApiClient.convertToType(data['domain'], Code);
            }
            if (data.hasOwnProperty('location')) {
                obj['location'] = ApiClient.convertToType(data['location'], Location);
            }
            if (data.hasOwnProperty('action')) {
                obj['action'] = ApiClient.convertToType(data['action'], 'String');
            }
            if (data.hasOwnProperty('version')) {
                obj['version'] = ApiClient.convertToType(data['version'], 'String');
            }
            if (data.hasOwnProperty('bap_id')) {
                obj['bap_id'] = ApiClient.convertToType(data['bap_id'], 'String');
            }
            if (data.hasOwnProperty('bap_uri')) {
                obj['bap_uri'] = ApiClient.convertToType(data['bap_uri'], 'String');
            }
            if (data.hasOwnProperty('bpp_id')) {
                obj['bpp_id'] = ApiClient.convertToType(data['bpp_id'], Model0);
            }
            if (data.hasOwnProperty('bpp_uri')) {
                obj['bpp_uri'] = ApiClient.convertToType(data['bpp_uri'], Model0);
            }
            if (data.hasOwnProperty('transaction_id')) {
                obj['transaction_id'] = ApiClient.convertToType(data['transaction_id'], 'String');
            }
            if (data.hasOwnProperty('message_id')) {
                obj['message_id'] = ApiClient.convertToType(data['message_id'], 'String');
            }
            if (data.hasOwnProperty('timestamp')) {
                obj['timestamp'] = ApiClient.convertToType(data['timestamp'], 'Date');
            }
            if (data.hasOwnProperty('key')) {
                obj['key'] = ApiClient.convertToType(data['key'], 'String');
            }
            if (data.hasOwnProperty('ttl')) {
                obj['ttl'] = ApiClient.convertToType(data['ttl'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>SupportPostRequestContext</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>SupportPostRequestContext</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of SupportPostRequestContext.RequiredProperties) {
            if (!data[property]) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // validate the optional field `location`
        if (data['location']) { // data not null
          Location.validateJSON(data['location']);
        }
        // ensure the json data is a string
        if (data['action'] && !(typeof data['action'] === 'string' || data['action'] instanceof String)) {
            throw new Error("Expected the field `action` to be a primitive type in the JSON string but got " + data['action']);
        }
        // ensure the json data is a string
        if (data['version'] && !(typeof data['version'] === 'string' || data['version'] instanceof String)) {
            throw new Error("Expected the field `version` to be a primitive type in the JSON string but got " + data['version']);
        }
        // ensure the json data is a string
        if (data['bap_id'] && !(typeof data['bap_id'] === 'string' || data['bap_id'] instanceof String)) {
            throw new Error("Expected the field `bap_id` to be a primitive type in the JSON string but got " + data['bap_id']);
        }
        // ensure the json data is a string
        if (data['bap_uri'] && !(typeof data['bap_uri'] === 'string' || data['bap_uri'] instanceof String)) {
            throw new Error("Expected the field `bap_uri` to be a primitive type in the JSON string but got " + data['bap_uri']);
        }
        // ensure the json data is a string
        if (data['transaction_id'] && !(typeof data['transaction_id'] === 'string' || data['transaction_id'] instanceof String)) {
            throw new Error("Expected the field `transaction_id` to be a primitive type in the JSON string but got " + data['transaction_id']);
        }
        // ensure the json data is a string
        if (data['message_id'] && !(typeof data['message_id'] === 'string' || data['message_id'] instanceof String)) {
            throw new Error("Expected the field `message_id` to be a primitive type in the JSON string but got " + data['message_id']);
        }
        // ensure the json data is a string
        if (data['key'] && !(typeof data['key'] === 'string' || data['key'] instanceof String)) {
            throw new Error("Expected the field `key` to be a primitive type in the JSON string but got " + data['key']);
        }
        // ensure the json data is a string
        if (data['ttl'] && !(typeof data['ttl'] === 'string' || data['ttl'] instanceof String)) {
            throw new Error("Expected the field `ttl` to be a primitive type in the JSON string but got " + data['ttl']);
        }

        return true;
    }


}

SupportPostRequestContext.RequiredProperties = ["action"];

/**
 * @member {module:model/Code} domain
 */
SupportPostRequestContext.prototype['domain'] = undefined;

/**
 * @member {module:model/Location} location
 */
SupportPostRequestContext.prototype['location'] = undefined;

/**
 * @member {module:model/SupportPostRequestContext.ActionEnum} action
 */
SupportPostRequestContext.prototype['action'] = undefined;

/**
 * Version of transaction protocol being used by the sender.
 * @member {String} version
 */
SupportPostRequestContext.prototype['version'] = undefined;

/**
 * A globally unique identifier of the platform, Typically it is the fully qualified domain name (FQDN) of the platform.
 * @member {String} bap_id
 */
SupportPostRequestContext.prototype['bap_id'] = undefined;

/**
 * The callback URL of the Subscriber. This should necessarily contain the same domain name as set in `subscriber_id``.
 * @member {String} bap_uri
 */
SupportPostRequestContext.prototype['bap_uri'] = undefined;

/**
 * @member {module:model/Model0} bpp_id
 */
SupportPostRequestContext.prototype['bpp_id'] = undefined;

/**
 * @member {module:model/Model0} bpp_uri
 */
SupportPostRequestContext.prototype['bpp_uri'] = undefined;

/**
 * This is a unique value which persists across all API calls from `search` through `confirm`. This is done to indicate an active user session across multiple requests. The BPPs can use this value to push personalized recommendations, and dynamic offerings related to an ongoing transaction despite being unaware of the user active on the BAP.
 * @member {String} transaction_id
 */
SupportPostRequestContext.prototype['transaction_id'] = undefined;

/**
 * This is a unique value which persists during a request / callback cycle. Since beckn protocol APIs are asynchronous, BAPs need a common value to match an incoming callback from a BPP to an earlier call. This value can also be used to ignore duplicate messages coming from the BPP. It is recommended to generate a fresh message_id for every new interaction. When sending unsolicited callbacks, BPPs must generate a new message_id.
 * @member {String} message_id
 */
SupportPostRequestContext.prototype['message_id'] = undefined;

/**
 * Time of request generation in RFC3339 format
 * @member {Date} timestamp
 */
SupportPostRequestContext.prototype['timestamp'] = undefined;

/**
 * The encryption public key of the sender
 * @member {String} key
 */
SupportPostRequestContext.prototype['key'] = undefined;

/**
 * The duration in ISO8601 format after timestamp for which this message holds valid
 * @member {String} ttl
 */
SupportPostRequestContext.prototype['ttl'] = undefined;


// Implement Context interface:
/**
 * @member {module:model/Code} domain
 */
Context.prototype['domain'] = undefined;
/**
 * @member {module:model/Location} location
 */
Context.prototype['location'] = undefined;
/**
 * The Beckn protocol method being called by the sender and executed at the receiver.
 * @member {String} action
 */
Context.prototype['action'] = undefined;
/**
 * Version of transaction protocol being used by the sender.
 * @member {String} version
 */
Context.prototype['version'] = undefined;
/**
 * A globally unique identifier of the platform, Typically it is the fully qualified domain name (FQDN) of the platform.
 * @member {String} bap_id
 */
Context.prototype['bap_id'] = undefined;
/**
 * The callback URL of the Subscriber. This should necessarily contain the same domain name as set in `subscriber_id``.
 * @member {String} bap_uri
 */
Context.prototype['bap_uri'] = undefined;
/**
 * @member {module:model/Model0} bpp_id
 */
Context.prototype['bpp_id'] = undefined;
/**
 * @member {module:model/Model0} bpp_uri
 */
Context.prototype['bpp_uri'] = undefined;
/**
 * This is a unique value which persists across all API calls from `search` through `confirm`. This is done to indicate an active user session across multiple requests. The BPPs can use this value to push personalized recommendations, and dynamic offerings related to an ongoing transaction despite being unaware of the user active on the BAP.
 * @member {String} transaction_id
 */
Context.prototype['transaction_id'] = undefined;
/**
 * This is a unique value which persists during a request / callback cycle. Since beckn protocol APIs are asynchronous, BAPs need a common value to match an incoming callback from a BPP to an earlier call. This value can also be used to ignore duplicate messages coming from the BPP. It is recommended to generate a fresh message_id for every new interaction. When sending unsolicited callbacks, BPPs must generate a new message_id.
 * @member {String} message_id
 */
Context.prototype['message_id'] = undefined;
/**
 * Time of request generation in RFC3339 format
 * @member {Date} timestamp
 */
Context.prototype['timestamp'] = undefined;
/**
 * The encryption public key of the sender
 * @member {String} key
 */
Context.prototype['key'] = undefined;
/**
 * The duration in ISO8601 format after timestamp for which this message holds valid
 * @member {String} ttl
 */
Context.prototype['ttl'] = undefined;



/**
 * Allowed values for the <code>action</code> property.
 * @enum {String}
 * @readonly
 */
SupportPostRequestContext['ActionEnum'] = {

    /**
     * value: "support"
     * @const
     */
    "support": "support"
};



export default SupportPostRequestContext;

