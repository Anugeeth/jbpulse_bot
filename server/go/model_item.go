/*
 * Beckn ODR API Specification
 *
 * Adaptation of Beckn protocol for the ODR sector.
 *
 * API version: 1.1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi




// Item - Describes a product or a service offered to the end consumer by the provider. In the mobility sector, it can represent a fare product like one way journey. In the logistics sector, it can represent the delivery service offering. In the retail domain it can represent a product like a grocery item.
type Item struct {

	// ID of the item.
	Id string `json:"id,omitempty"`

	ParentItemId Id `json:"parent_item_id,omitempty"`

	ParentItemQuantity ItemQuantity `json:"parent_item_quantity,omitempty"`

	Descriptor Descriptor `json:"descriptor,omitempty"`

	Creator Organization `json:"creator,omitempty"`

	Price Price `json:"price,omitempty"`

	Quantity ItemQuantity `json:"quantity,omitempty"`

	// Categories this item can be listed under
	CategoryIds []Id `json:"category_ids,omitempty"`

	// Modes through which this item can be fulfilled
	FulfillmentIds []Id `json:"fulfillment_ids,omitempty"`

	// Provider Locations this item is available in
	LocationIds []Id `json:"location_ids,omitempty"`

	// Payment modalities through which this item can be ordered
	PaymentIds []Id `json:"payment_ids,omitempty"`

	AddOns []AddOn `json:"add_ons,omitempty"`

	// Cancellation terms of this item
	CancellationTerms []CancellationTerm `json:"cancellation_terms,omitempty"`

	// Refund terms of this item
	RefundTerms []ItemRefundTermsInner `json:"refund_terms,omitempty"`

	// Terms that are applicable be met when this item is replaced
	ReplacementTerms []ReplacementTerm `json:"replacement_terms,omitempty"`

	// Terms that are applicable when this item is returned
	ReturnTerms []ReturnTerm `json:"return_terms,omitempty"`

	Xinput XInput `json:"xinput,omitempty"`

	Time Time `json:"time,omitempty"`

	// Whether this item can be rated
	Rateable bool `json:"rateable,omitempty"`

	Rating Value `json:"rating,omitempty"`

	// Whether this item is an exact match of the request
	Matched bool `json:"matched,omitempty"`

	// Whether this item is a related item to the exactly matched item
	Related bool `json:"related,omitempty"`

	// Whether this item is a recommended item to a response
	Recommended bool `json:"recommended,omitempty"`

	// Time to live in seconds for an instance of this schema
	Ttl string `json:"ttl,omitempty"`

	Tags []TagGroup `json:"tags,omitempty"`
}

// AssertItemRequired checks if the required fields are not zero-ed
func AssertItemRequired(obj Item) error {
	if err := AssertItemQuantityRequired(obj.ParentItemQuantity); err != nil {
		return err
	}
	if err := AssertDescriptorRequired(obj.Descriptor); err != nil {
		return err
	}
	if err := AssertOrganizationRequired(obj.Creator); err != nil {
		return err
	}
	if err := AssertPriceRequired(obj.Price); err != nil {
		return err
	}
	if err := AssertItemQuantityRequired(obj.Quantity); err != nil {
		return err
	}
	for _, el := range obj.AddOns {
		if err := AssertAddOnRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.CancellationTerms {
		if err := AssertCancellationTermRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.RefundTerms {
		if err := AssertItemRefundTermsInnerRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ReplacementTerms {
		if err := AssertReplacementTermRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ReturnTerms {
		if err := AssertReturnTermRequired(el); err != nil {
			return err
		}
	}
	if err := AssertXInputRequired(obj.Xinput); err != nil {
		return err
	}
	if err := AssertTimeRequired(obj.Time); err != nil {
		return err
	}
	for _, el := range obj.Tags {
		if err := AssertTagGroupRequired(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertItemConstraints checks if the values respects the defined constraints
func AssertItemConstraints(obj Item) error {
	return nil
}
